class s extends Error{}const e="__$dispose";function o(s){if("object"==typeof s&&null!==s&&"function"==typeof s[e])try{s[e]()}catch(s){return s}}function t(s){return"object"==typeof s&&null!==s&&"function"==typeof s[Symbol.iterator]?[...s].map(o):[]}var i=Object.freeze({__proto__:null,DisposedError:s,checkDisposed:function(e){if(e.disposed)throw new s("Try to access to a disposed instance")},create:function(s){return{[e]:()=>{s&&s()}}},dispose:e,safeDispose:o,safeDisposeAll:t});class r{constructor(){this._disposables=void 0,this._disposed=!1}get disposed(){return Boolean(this._disposed)}registerForDispose(...s){for(const e of s)this._disposables?this._disposables.add(e):this._disposables=new Set([e])}checkIfDisposed(){checkDisposed(this)}[e](){this._disposed||(this._disposed=!0,t(this._disposables),delete this._disposables,this.dispose&&this.dispose())}}function p(s){class e extends s{}for(const s of Reflect.ownKeys(r.prototype)){const o={...Reflect.getOwnPropertyDescriptor(r.prototype,s)};Reflect.defineProperty(e.prototype,s,o)}return e}class n{constructor(s){this.global=s}getValue(s){return this.global[s]}setValue(s,e){return this.global[s]=e}deleteKey(s){delete this.global[s]}}class c extends n{constructor(){super(__$$app$$__.__globals__.__scopedGlobals__)}}class l{constructor(s){this.name="AppDispose_"+s}dispose(){}}function d(s){const t=new c,r=p(l),n=s[e]=new r(__$$app$$__.pid);return t.setValue(e,n),s.$m={Dispose:{Disposable:i,IDisposable:p},G:{App:t}},{onDestroy(){o(n),t.deleteKey(e)}}}function a(){return(new c).getValue(e)}const _="3.0";export{_ as API_LEVEL,i as Disposable,d as appPlugin,a as getAppDisposer};
